---
phase: 06-json-output
plan: 02
type: execute
depends_on: ["06-01"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Generate UUID for execution_id and add match_id to Match.

Purpose: Add unique identifiers for traceability - execution_id for the search run, match_id for each match.
Output: UUID generation integrated, match_id field added to Match struct
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6-01 provides Serialize structs:
@.planning/phases/06-json-output/06-01-SUMMARY.md

# Current state:
@src/main.rs - Match and SearchOutput structs have Serialize derives
@Cargo.toml - uuid dependency already present with v4 and serde features
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add match_id field to Match struct</name>
  <files>src/main.rs</files>
  <action>Add match_id field to Match struct and update search_files:
```rust
#[derive(Serialize)]
struct Match {
    match_id: String,  // NEW - UUID for this match
    file: String,
    byte_start: usize,
    byte_end: usize,
    matched_text: String,
    line_number: usize,
    column_number: usize,
    context_before: String,
    context_after: String,
}
```

Update search_files to generate match_id for each match:
```rust
use uuid::Uuid;

// In search_files, when creating Match:
matches.push(Match {
    match_id: Uuid::new_v4().to_string(),
    file: file_path.clone(),
    byte_start,
    byte_end,
    matched_text: mat.as_str().to_string(),
    line_number: line_num,
    column_number: col_num,
    context_before,
    context_after,
});
```

Key notes:
- Add `use uuid::Uuid;` import at top
- Each match gets unique UUID for traceability
- match_id is first field in struct (appears first in JSON output)
</action>
  <verify>`cargo build` succeeds</verify>
  <done>match_id field added and populated with UUID</done>
</task>

<task type="auto">
  <name>Task 2: Generate execution_id in main function</name>
  <files>src/main.rs</files>
  <action>In main function, generate execution_id after parsing args:
```rust
fn main() {
    let args = cli::Cli::parse();

    // Generate execution_id for this search run
    let execution_id = Uuid::new_v4().to_string();
    eprintln!("Execution ID: {}", execution_id);

    // ... rest of main
}
```

Then update the TODO comment for SearchOutput construction:
```rust
    // Phase 6: JSON output
    // TODO: Build SearchOutput with execution_id and serialize to JSON
```

Key notes:
- execution_id generated once per run (not per match)
- Stored as String for easy serialization
- Printed to stderr for debugging (stderr won't be part of JSON output)
</action>
  <verify>`cargo build` succeeds</verify>
  <done>execution_id generated and available in main</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] Match struct has match_id field
- [ ] search_files populates match_id with UUID
- [ ] main function generates execution_id
- [ ] uuid::Uuid imported
</verification>

<success_criteria>

- Each match has unique match_id (UUID v4)
- Each search run has unique execution_id (UUID v4)
- Ready for JSON serialization in 06-03
  </success_criteria>

<output>
After completion, create `.planning/phases/06-json-output/06-02-SUMMARY.md`
</output>
