---
phase: 06-json-output
plan: 03
type: execute
depends_on: ["06-02"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Serialize matches to JSON format with proper output structure.

Purpose: Build SearchOutput struct and serialize to JSON stdout for LLM consumption.
Output: Complete JSON output with execution_id, pattern, matches array
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6-01 provides Serialize structs:
@.planning/phases/06-json-output/06-01-SUMMARY.md

# Phase 6-02 provides UUID generation:
@.planning/phases/06-json-output/06-02-SUMMARY.md

# Current state:
@src/main.rs - Match has match_id, main has execution_id, SearchOutput struct exists
@Cargo.toml - serde_json dependency already present
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build SearchOutput and serialize to JSON</name>
  <files>src/main.rs</files>
  <action>Replace the Phase 6 TODO section with actual JSON output:
```rust
    // Phase 6: JSON output
    let output = SearchOutput {
        execution_id: execution_id.clone(),
        pattern: args.pattern.clone(),
        matches: matches.clone(),
        match_count: matches.len(),
    };

    // Serialize to JSON (pretty-printed for now, compact in Phase 8 with --json flag)
    match serde_json::to_string_pretty(&output) {
        Ok(json) => {
            // For now, print to stderr for debugging
            // Phase 8 will handle --json flag and stdout routing
            eprintln!();
            eprintln!("JSON Output:");
            eprintln!("{}", json);
        }
        Err(e) => {
            eprintln!("Error serializing to JSON: {}", e);
            std::process::exit(1);
        }
    }
```

Add import at top if not present:
```rust
use serde_json;
```

Key implementation notes:
- Clone execution_id and pattern for Output (ownership transfer)
- Use to_string_pretty for debugging (readable during development)
- Print to stderr for now (stdout reserved for final JSON in Phase 8)
- Error handling for JSON serialization failures
</action>
  <verify>`cargo build` succeeds</verify>
  <done>SearchOutput built and serialized to JSON</done>
</task>

<task type="auto">
  <name>Task 2: Update debug output to show match_id</name>
  <files>src/main.rs</files>
  <action>Update the debug loop to include match_id:
```rust
    // Debug: print first few matches with context
    for (i, m) in matches.iter().take(3).enumerate() {
        eprintln!("  Match {}: {} (id: {})", i + 1, m.file, m.match_id);
        eprintln!("    {}:{}:{}", m.file, m.line_number, m.column_number);
        eprintln!("    Before: \"{}\"", m.context_before);
        eprintln!("    Match:  \"{}\"", m.matched_text.chars().take(30).collect::<String>());
        eprintln!("    After:  \"{}\"", m.context_after);
    }
```

This shows:
- Match number (sequential for readability)
- File path
- match_id (UUID for traceability)
- Line/column position
- Context before, match text, context after
</action>
  <verify>`cargo build` succeeds and running llmsearch shows match_id in debug output</verify>
  <done>Debug output includes match_id for verification</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] SearchOutput constructed with execution_id, pattern, matches, match_count
- [ ] JSON output prints to stderr (pretty-printed for debugging)
- [ ] Debug output shows match_id
- [ ] No errors on empty matches (0 match_count handled correctly)
</verification>

<success_criteria>

- Complete JSON schema implemented
- execution_id uniquely identifies search run
- Each match has unique match_id for traceability
- JSON structure ready for Phase 7 (deterministic ordering) and Phase 8 (--json flag)
- Phase 6 complete: JSON output schema fully functional
  </success_criteria>

<output>
After completion, create `.planning/phases/06-json-output/06-03-SUMMARY.md`
</output>
