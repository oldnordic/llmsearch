---
phase: 02-file-walking
plan: 03
type: execute
depends_on: ["02-02"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Add UTF-8 text file detection to filter binary files.

Purpose: Skip binary files (images, compiled artifacts) and only search text files. This prevents searching binary content that won't contain meaningful text matches.
Output: File walker that detects and filters out binary files
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 2-02 provides:
@.planning/phases/02-file-walking/02-02-SUMMARY.md

# Current state:
@src/main.rs - walk_files function with glob filtering, no binary detection yet
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UTF-8 text file detection helper</name>
  <files>src/main.rs</files>
  <action>Add binary file detection to skip non-text files:

1. Add a helper function to detect if a file is text:
```rust
use std::path::Path;

fn is_text_file(path: &Path) -> bool {
    // Try to read first few bytes to check for binary content
    match std::fs::read(path) {
        Ok(contents) => {
            // Check first 8KB for null bytes (common in binary files)
            let sample_size = 8192.min(contents.len());
            let sample = &contents[..sample_size];

            // If we find a null byte, it's likely binary
            if sample.contains(&0u8) {
                return false;
            }

            // Check for UTF-8 validity
            std::str::from_utf8(sample).is_ok()
        }
        Err(_) => false, // Can't read file, skip it
    }
}
```

2. Update walk_files to filter by text detection:
```rust
fn walk_files(root: &str, globs: &[String]) -> Vec<String> {
    let mut walker = WalkBuilder::new(root);
    walker.hidden(false);
    walker.git_ignore(true);
    walker.parents(true);

    let mut files = Vec::new();

    for result in walker.build() {
        match result {
            Ok(entry) => {
                let path = entry.path();

                // Only include files, not directories
                if !entry.file_type().map_or(false, |ft| ft.is_file()) {
                    continue;
                }

                // Skip binary files
                if !is_text_file(path) {
                    continue;
                }

                if let Some(path_str) = path.to_str() {
                    // Apply glob filtering if patterns provided
                    if !globs.is_empty() {
                        let filename = entry.file_name().to_string_lossy();
                        let matches: bool = globs.iter().any(|g| {
                            if g.starts_with("*.") {
                                let ext = &g[2..];
                                filename.ends_with(ext)
                            } else if g.contains('*') {
                                let pattern = g.replace(".", "\\.").replace("*", ".*");
                                if let Ok(re) = regex::Regex::new(&pattern) {
                                    re.is_match(&filename)
                                } else {
                                    false
                                }
                            } else {
                                filename == *g
                            }
                        });

                        if !matches {
                            continue;
                        }
                    }

                    files.push(path_str.to_string());
                }
            }
            Err(err) => {
                eprintln!("Warning: {}", err);
            }
        }
    }

    files
}
```

Key implementation notes:
- Read first 8KB max to check for binary content
- Null bytes (0x00) indicate binary files
- UTF-8 validation ensures text is decodable
- Files that can't be read are skipped (permission errors, etc.)
- This is a heuristic - good enough for ripgrep-style tool
</action>
  <verify>`cargo build` succeeds</verify>
  <done>Binary files like .png, .so are excluded from results</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] Text files (.rs, .md, .txt) are included
- [ ] Binary files (.png, .jpg, .so, .zip) are excluded
- [ ] UTF-8 encoded files are handled correctly
- [ ] Files with read errors are skipped gracefully
</verification>

<success_criteria>

- Binary file detection working
- Only text files included in search results
- Graceful handling of unreadable files
- Phase 2 complete: file walking with ignore, glob filtering, and text detection
  </success_criteria>

<output>
After completion, create `.planning/phases/02-file-walking/02-03-SUMMARY.md`
</output>
