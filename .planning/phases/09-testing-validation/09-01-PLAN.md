---
phase: 09-testing-validation
plan: 01
type: execute
depends_on: []
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Add comprehensive unit tests for edge cases and core functions.

Purpose: Increase test coverage for edge cases in file walking, text detection, and search logic.
Output: Additional unit tests in src/main.rs
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add binary file detection tests</name>
  <files>src/main.rs</files>
  <action>Add tests to verify is_text_file() correctly identifies binary and text files:

```rust
#[test]
fn test_is_text_file_with_null_bytes() {
    // Create a temp file with null bytes (binary indicator)
    use std::io::Write;
    let temp_dir = std::env::temp_dir();
    let file_path = temp_dir.join("test_binary.bin");
    let mut file = std::fs::File::create(&file_path).unwrap();
    file.write_all(b"\x00\x01\x02\x03\x04").unwrap();

    assert!(!is_text_file(&file_path));
    std::fs::remove_file(&file_path).unwrap();
}

#[test]
fn test_is_text_file_with_valid_utf8() {
    use std::io::Write;
    let temp_dir = std::env::temp_dir();
    let file_path = temp_dir.join("test_text.txt");
    let mut file = std::fs::File::create(&file_path).unwrap();
    file.write_all(b"Hello, world!").unwrap();

    assert!(is_text_file(&file_path));
    std::fs::remove_file(&file_path).unwrap();
}

#[test]
fn test_is_text_file_with_invalid_utf8() {
    use std::io::Write;
    let temp_dir = std::env::temp_dir();
    let file_path = temp_dir.join("test_invalid.txt");
    let mut file = std::fs::File::create(&file_path).unwrap();
    // Invalid UTF-8 sequence
    file.write_all(b"\xFF\xFE Hello").unwrap();

    assert!(!is_text_file(&file_path));
    std::fs::remove_file(&file_path).unwrap();
}

#[test]
fn test_is_text_file_nonexistent() {
    let path = Path::new("/nonexistent/file/that/does/not/exist");
    assert!(!is_text_file(path));
}
```

Tests verify:
- Null byte detection returns false
- Valid UTF-8 text returns true
- Invalid UTF-8 returns false
- Non-existent files return false gracefully
</action>
  <verify>`cargo test test_is_text_file` passes all 4 tests</verify>
  <done>Binary and text file detection thoroughly tested</done>
</task>

<task type="auto">
  <name>Task 2: Add line index edge case tests</name>
  <files>src/main.rs</files>
  <action>Add tests for line index edge cases:

```rust
#[test]
fn test_build_line_index_empty_string() {
    let line_index = build_line_index("");
    assert_eq!(line_index, vec![0]); // Only line 0 at byte 0
}

#[test]
fn test_build_line_index_no_newlines() {
    let line_index = build_line_index("Hello world");
    assert_eq!(line_index, vec![0]); // Single line
}

#[test]
fn test_build_line_index_multiple_newlines() {
    let line_index = build_line_index("a\nb\nc");
    assert_eq!(line_index, vec![0, 2, 4]); // Lines at 0, 2, 4
}

#[test]
fn test_build_line_index_trailing_newline() {
    let line_index = build_line_index("a\nb\n");
    assert_eq!(line_index, vec![0, 2, 4]); // Empty line at end
}

#[test]
fn test_byte_to_line_at_exact_match() {
    let line_index = vec![0, 5, 10, 15];
    assert_eq!(byte_to_line(5, &line_index), 2); // Exact match at line 2
}

#[test]
fn test_byte_to_line_at_end_of_file() {
    let line_index = vec![0, 5, 10];
    assert_eq!(byte_to_line(14, &line_index), 3); // In line 3 (index 2 + 1)
}

#[test]
fn test_byte_to_line_at_byte_zero() {
    let line_index = vec![0, 10, 20];
    assert_eq!(byte_to_line(0, &line_index), 1); // First line
}
```

Tests verify:
- Empty string handling
- Single line (no newlines)
- Multiple newlines
- Trailing newlines
- Exact byte matches
- End of file positions
- Byte zero (first position)
</action>
  <verify>`cargo test test_build_line_index test_byte_to_line` passes all tests</verify>
  <done>Line index edge cases thoroughly tested</done>
</task>

<task type="auto">
  <name>Task 3: Add glob pattern filtering tests</name>
  <files>src/main.rs</files>
  <action>Add tests for walk_files glob filtering (requires setup):

```rust
#[test]
fn test_walk_files_filters_by_extension() {
    use std::io::Write;
    let temp_dir = std::env::temp_dir();

    // Create test files
    let rust_file = temp_dir.join("test.rs");
    let toml_file = temp_dir.join("test.toml");
    let txt_file = temp_dir.join("test.txt");
    std::fs::File::create(&rust_file).unwrap().write_all(b"fn main() {}").unwrap();
    std::fs::File::create(&toml_file).unwrap().write_all(b"[package]").unwrap();
    std::fs::File::create(&txt_file).unwrap().write_all(b"text").unwrap();

    let temp_str = temp_dir.to_str().unwrap();
    let files = walk_files(temp_str, &["*.rs".to_string()]);

    // Should only find .rs files
    assert_eq!(files.len(), 1);
    assert!(files[0].ends_with("test.rs"));

    // Cleanup
    std::fs::remove_file(&rust_file).unwrap();
    std::fs::remove_file(&toml_file).unwrap();
    std::fs::remove_file(&txt_file).unwrap();
}

#[test]
fn test_walk_files_multiple_globs() {
    use std::io::Write;
    let temp_dir = std::env::temp_dir();

    let rust_file = temp_dir.join("test.rs");
    let toml_file = temp_dir.join("test.toml");
    let txt_file = temp_dir.join("test.txt");
    std::fs::File::create(&rust_file).unwrap().write_all(b"fn main() {}").unwrap();
    std::fs::File::create(&toml_file).unwrap().write_all(b"[package]").unwrap();
    std::fs::File::create(&txt_file).unwrap().write_all(b"text").unwrap();

    let temp_str = temp_dir.to_str().unwrap();
    let globs = vec!["*.rs".to_string(), "*.toml".to_string()];
    let files = walk_files(temp_str, &globs);

    // Should find both .rs and .toml files
    assert_eq!(files.len(), 2);
    let has_rust = files.iter().any(|f| f.ends_with("test.rs"));
    let has_toml = files.iter().any(|f| f.ends_with("test.toml"));
    assert!(has_rust && has_toml);

    // Cleanup
    std::fs::remove_file(&rust_file).unwrap();
    std::fs::remove_file(&toml_file).unwrap();
    std::fs::remove_file(&txt_file).unwrap();
}

#[test]
fn test_walk_files_no_globs_returns_all() {
    use std::io::Write;
    let temp_dir = std::env::temp_dir();

    let rust_file = temp_dir.join("test.rs");
    let txt_file = temp_dir.join("test.txt");
    std::fs::File::create(&rust_file).unwrap().write_all(b"fn main() {}").unwrap();
    std::fs::File::create(&txt_file).unwrap().write_all(b"text").unwrap();

    let temp_str = temp_dir.to_str().unwrap();
    let files = walk_files(temp_str, &[]);

    // Should find all text files
    assert_eq!(files.len(), 2);

    // Cleanup
    std::fs::remove_file(&rust_file).unwrap();
    std::fs::remove_file(&txt_file).unwrap();
}
```

Tests verify:
- Single extension glob filtering
- Multiple glob patterns (OR logic)
- No globs returns all text files
- Only text files returned (binary files skipped)
</action>
  <verify>`cargo test test_walk_files` passes all 3 tests</verify>
  <done>File walking with glob filtering tested</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo test` passes all existing and new tests
- [ ] test_is_text_file tests verify binary detection
- [ ] test_build_line_index covers edge cases
- [ ] test_walk_files verifies glob filtering
- [ ] All tests run clean with no warnings
</verification>

<success_criteria>

- 10+ new unit tests added
- Edge cases covered for is_text_file, build_line_index, walk_files
- All tests pass
- Ready for integration tests in 09-02
  </success_criteria>

<output>
After completion, create `.planning/phases/09-testing-validation/09-01-SUMMARY.md`
</output>
