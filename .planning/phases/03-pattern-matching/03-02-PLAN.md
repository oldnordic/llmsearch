---
phase: 03-pattern-matching
plan: 02
type: execute
depends_on: ["03-01"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Search file contents with regex and collect byte offsets.

Purpose: Iterate through files, read their contents, and find all regex matches with their byte positions. Byte offsets are critical for later line/column calculation.
Output: Vector of matches with file path and byte offsets
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 3-01 provides compiled regex:
@.planning/phases/03-pattern-matching/03-01-SUMMARY.md

# Phase 2 provides file list:
@.planning/phases/02-file-walking/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search function with byte offset tracking</name>
  <files>src/main.rs</files>
  <action>Add a `search_files` function that searches each file and tracks byte offsets:

1. Define a Match struct to hold results:
```rust
struct Match {
    file: String,
    byte_start: usize,
    byte_end: usize,
}
```

2. Create search_files function:
```rust
fn search_files(files: &[String], regex: &Regex) -> Vec<Match> {
    let mut matches = Vec::new();

    for file_path in files {
        // Read file content
        match std::fs::read_to_string(file_path) {
            Ok(content) => {
                // Find all regex matches with byte offsets
                for mat in regex.find_iter(&content) {
                    matches.push(Match {
                        file: file_path.clone(),
                        byte_start: mat.start(),
                        byte_end: mat.end(),
                    });
                }
            }
            Err(e) => {
                eprintln!("Warning: Could not read {}: {}", file_path, e);
            }
        }
    }

    matches
}
```

3. Update main to call search_files:
```rust
// Phase 3: Pattern matching
// Search files for pattern matches
let matches = search_files(&files, &regex);
eprintln!("Found {} matches", matches.len());
```

4. Remove the old placeholder line for _matches

Key implementation notes:
- regex.find_iter() returns all matches with byte offsets
- byte_start and byte_end are byte positions (NOT character positions)
- read_to_string() handles UTF-8 decoding
- Graceful error handling for unreadable files
- Match struct is simple - will be expanded in later phases
</action>
  <verify>`cargo build` succeeds</verify>
  <done>Searching for a pattern finds matches with correct byte offsets</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] `cargo run -- --pattern "fn main" --root src` finds matches
- [ ] Byte offsets are tracked (print a match to verify)
- [ ] Files with read errors are skipped gracefully
</verification>

<success_criteria>

- search_files function reads and searches each file
- Byte offsets (start/end) captured for each match
- Regex find_iter finds all non-overlapping matches
- Read errors handled with eprintln, not crashes
- Match count printed to stderr
  </success_criteria>

<output>
After completion, create `.planning/phases/03-pattern-matching/03-02-SUMMARY.md`
</output>
