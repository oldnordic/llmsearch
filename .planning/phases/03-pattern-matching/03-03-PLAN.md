---
phase: 03-pattern-matching
plan: 03
type: execute
depends_on: ["03-02"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Add matched text extraction and verify byte offset accuracy.

Purpose: Capture the actual matched text content and verify that byte offsets correctly identify the matched content. This prepares data for context extraction in phase 5.
Output: Match struct with matched text content and verified byte positions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 3-02 provides search with byte offsets:
@.planning/phases/03-pattern-matching/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract matched text and add match content verification</name>
  <files>src/main.rs</files>
  <action>Update the Match struct and search_files to capture matched text:

1. Update Match struct to include matched text:
```rust
struct Match {
    file: String,
    byte_start: usize,
    byte_end: usize,
    matched_text: String,
}
```

2. Update search_files to capture the matched text:
```rust
fn search_files(files: &[String], regex: &Regex) -> Vec<Match> {
    let mut matches = Vec::new();

    for file_path in files {
        match std::fs::read_to_string(file_path) {
            Ok(content) => {
                for mat in regex.find_iter(&content) {
                    matches.push(Match {
                        file: file_path.clone(),
                        byte_start: mat.start(),
                        byte_end: mat.end(),
                        matched_text: mat.as_str().to_string(),
                    });
                }
            }
            Err(e) => {
                eprintln!("Warning: Could not read {}: {}", file_path, e);
            }
        }
    }

    matches
}
```

3. Add verification output in main:
```rust
// Phase 3: Pattern matching
// Search files for pattern matches
let matches = search_files(&files, &regex);
eprintln!("Found {} matches", matches.len());

// Debug: print first few matches to verify
for (i, m) in matches.iter().take(3).enumerate() {
    eprintln!("  Match {}: {} at {}:{} - \"{}\"",
        i + 1, m.file, m.byte_start, m.byte_end,
        m.matched_text.chars().take(50).collect::<String>()
    );
}
```

Key implementation notes:
- mat.as_str() returns the actual matched text slice
- matched_text stored as String for later JSON output
- Debug output limited to first 3 matches and 50 chars to avoid spam
- Byte offsets verified by extracting text from the same range
- Multi-byte UTF-8 handled correctly by regex crate (uses byte indices)
</action>
  <verify>`cargo build` succeeds</verify>
  <done>Matched text is correctly extracted and byte offsets align with content</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] `cargo run -- --pattern "fn" --glob "*.rs" --root src` prints matches with text
- [ ] Matched text displayed in debug output
- [ ] Byte offsets correctly correspond to matched text positions
- [ ] Multi-byte UTF-8 characters in matches don't break offset calculation
</verification>

<success_criteria>

- Match struct includes matched_text field
- Byte offsets accurately locate matched content in files
- Debug output shows sample matches for verification
- Phase 3 complete: regex search with byte offset tracking and match content
  </success_criteria>

<output>
After completion, create `.planning/phases/03-pattern-matching/03-03-SUMMARY.md`
</output>
