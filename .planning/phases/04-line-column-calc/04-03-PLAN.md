---
phase: 04-line-column-calc
plan: 03
type: execute
depends_on: ["04-02"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Verify multi-byte UTF-8 character handling in column calculation.

Purpose: Create verification tests and add debug output to confirm that multi-byte UTF-8 characters (emoji, accented letters, etc.) are counted correctly as single column positions, not multiple columns.
Output: Verified UTF-8 handling with test coverage
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 4-02 provides line/col calculation:
@.planning/phases/04-line-column-calc/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UTF-8 verification test and debug output</name>
  <files>src/main.rs</files>
  <action>Add verification for multi-byte UTF-8 handling:

1. Create a test function to verify UTF-8 column calculation:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_utf8_column_calculation() {
        // Test with multi-byte UTF-8 characters
        let content = "Hello ä¸–ç•ŒğŸŒ";  // "ä¸–ç•Œ" = 6 bytes, "ğŸŒ" = 4 bytes
        let line_index = build_line_index(content);

        // "ä¸–" starts at byte 6
        let byte_offset = 6;
        let line_num = byte_to_line(byte_offset, &line_index);
        let line_start = line_index[line_num - 1];
        let col_num = byte_to_column(byte_offset, line_start, content);

        assert_eq!(line_num, 1);
        assert_eq!(col_num, 7);  // "Hello " (6 chars) + "ä¸–" (1 char) = position 7

        // "ğŸŒ" starts at byte 12 (6 + 6 for "ä¸–ç•Œ")
        let byte_offset_emoji = 12;
        let col_num_emoji = byte_to_column(byte_offset_emoji, line_start, content);
        assert_eq!(col_num_emoji, 9);  // "Hello ä¸–ç•Œ" (8 chars) + "ğŸŒ" (1 char) = position 9
    }

    #[test]
    fn test_line_index_multibyte() {
        let content = "a\nä¸–ç•ŒğŸŒ\nb";
        let line_index = build_line_index(content);

        // Line 1 starts at 0
        assert_eq!(line_index[0], 0);
        // Line 2 starts at byte 2 (after "a\n")
        assert_eq!(line_index[1], 2);
        // Line 3 starts at byte 12 (after "ä¸–ç•ŒğŸŒ\n" = 10 bytes + 1 newline)
        assert_eq!(line_index[2], 12);
    }
}
```

2. Add a debug helper to show UTF-8 handling in main (optional, for verification):
```rust
// At the end of main, after match output, add a verification note:
eprintln!();
eprintln!("UTF-8 handling: Column numbers count Unicode characters, not bytes");
eprintln!("  Multi-byte characters (emoji, accented letters) count as 1 column");
```

Key implementation notes:
- .chars().count() correctly handles UTF-8 (counts codepoints, not bytes)
- Test verifies that "ä¸–ç•Œ" (6 bytes) and "ğŸŒ" (4 bytes) each count as 1 column
- line_index uses byte offsets (efficient), but columns use character counts (correct)
- Tests run with `cargo test` and verify UTF-8 handling

3. Run tests to verify:
```bash
cargo test utf8_column
cargo test line_index_multibyte
```
</action>
  <verify>`cargo test` passes all UTF-8 tests</verify>
  <done>UTF-8 tests verify multi-byte characters counted correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo test` passes the new UTF-8 tests
- [ ] Test verifies emoji (4 bytes) counts as 1 column
- [ ] Test verifies CJK characters (3 bytes each) count correctly
- [ ] Manual verification: create test file with multi-byte chars, search, verify columns
</verification>

<success_criteria>

- UTF-8 test coverage added for column calculation
- Tests verify multi-byte characters counted as single columns
- line_index correctly tracks byte positions of newlines
- Phase 4 complete: byte offsets â†’ line/col with proper UTF-8 handling
  </success_criteria>

<output>
After completion, create `.planning/phases/04-line-column-calc/04-03-SUMMARY.md`
</output>
