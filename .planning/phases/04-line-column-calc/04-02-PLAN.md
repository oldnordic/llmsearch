---
phase: 04-line-column-calc
plan: 02
type: execute
depends_on: ["04-01"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Convert byte offsets to line and column positions.

Purpose: Use the line index from 04-01 to convert Match byte offsets to human-readable line/column numbers. Add line/col fields to Match struct.
Output: Match struct with line_number and column_number fields populated
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 4-01 provides line index functions:
@.planning/phases/04-line-column-calc/04-01-SUMMARY.md

# Phase 3 provides Match struct:
@.planning/phases/03-pattern-matching/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add line/col to Match struct and integrate calculation</name>
  <files>src/main.rs</files>
  <action>Update Match struct and add column calculation:

1. Update Match struct to include line/col:
```rust
struct Match {
    file: String,
    byte_start: usize,
    byte_end: usize,
    matched_text: String,
    line_number: usize,
    column_number: usize,
}
```

2. Add column calculation function:
```rust
/// Given a byte offset and line start, returns the column (1-indexed)
/// Counts Unicode codepoints, not bytes, for correct column numbers
fn byte_to_column(byte_offset: usize, line_start: usize, content: &str) -> usize {
    // Get the slice from line start to our byte offset
    let line_prefix = &content[line_start..byte_offset];

    // Count characters (codepoints), not bytes
    // This handles multi-byte UTF-8 correctly
    line_prefix.chars().count() + 1  // +1 for 1-indexed columns
}
```

3. Update search_files to calculate line/col:
```rust
fn search_files(files: &[String], regex: &Regex) -> Vec<Match> {
    let mut matches = Vec::new();

    for file_path in files {
        match std::fs::read_to_string(file_path) {
            Ok(content) => {
                // Build line index for this file
                let line_index = build_line_index(&content);

                for mat in regex.find_iter(&content) {
                    let byte_start = mat.start();
                    let line_num = byte_to_line(byte_start, &line_index);
                    let line_start_byte = line_index[line_num - 1];
                    let col_num = byte_to_column(byte_start, line_start_byte, &content);

                    matches.push(Match {
                        file: file_path.clone(),
                        byte_start,
                        byte_end: mat.end(),
                        matched_text: mat.as_str().to_string(),
                        line_number: line_num,
                        column_number: col_num,
                    });
                }
            }
            Err(e) => {
                eprintln!("Warning: Could not read {}: {}", file_path, e);
            }
        }
    }

    matches
}
```

4. Update debug output to show line/col:
```rust
for (i, m) in matches.iter().take(3).enumerate() {
    eprintln!("  Match {}: {}:{}:{} - \"{}\"",
        i + 1, m.file, m.line_number, m.column_number,
        m.matched_text.chars().take(50).collect::<String>()
    );
}
```

Key implementation notes:
- line_number is 1-indexed (line 1, not line 0)
- column_number counts Unicode codepoints (not bytes) for proper multi-byte handling
- line_prefix.chars().count() correctly handles UTF-8 multi-byte sequences
- Line index rebuilt per file (each file has different line structure)
</action>
  <verify>`cargo build` succeeds</verify>
  <done>Running search shows matches with line:col format</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] `cargo run -- --pattern "fn" --glob "*.rs"` shows line:col for each match
- [ ] Line numbers are 1-indexed (first line is line 1)
- [ ] Column numbers count characters, not bytes
- [ ] Multi-byte UTF-8 characters counted as single column positions
</verification>

<success_criteria>

- Match struct includes line_number and column_number
- Line numbers calculated from byte offsets using line index
- Column numbers count Unicode codepoints (not bytes)
- Output format file:line:col matches standard grep format
  </success_criteria>

<output>
After completion, create `.planning/phases/04-line-column-calc/04-02-SUMMARY.md`
</output>
