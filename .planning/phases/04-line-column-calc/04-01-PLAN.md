---
phase: 04-line-column-calc
plan: 01
type: execute
depends_on: []
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Build line index from file content for byte-to-line conversion.

Purpose: Create a helper function that builds an index of newline positions in a file. This index allows efficient lookup of which line a given byte offset belongs to.
Output: Line index function that maps byte offsets to line numbers
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 3 provides Match struct with byte offsets:
@.planning/phases/03-pattern-matching/03-03-SUMMARY.md

# Current state:
@src/main.rs - Match struct has byte_start, byte_end fields
@Cargo.toml - All dependencies present (regex, std included for line indexing)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create line index builder function</name>
  <files>src/main.rs</files>
  <action>Add a `build_line_index` function that creates a lookup table:

1. Add the function after search_files:
```rust
/// Builds an index of newline positions for byte-to-line conversion
/// Returns a Vec where index[i] = byte offset of line i (0-indexed)
fn build_line_index(content: &str) -> Vec<usize> {
    let mut line_starts = vec![0]; // Line 0 starts at byte 0

    for (byte_offset, ch) in content.char_indices() {
        if ch == '\n' {
            // Next line starts after this newline
            line_starts.push(byte_offset + 1);
        }
    }

    line_starts
}

/// Given a byte offset and line index, returns the line number (1-indexed)
fn byte_to_line(byte_offset: usize, line_index: &[usize]) -> usize {
    // Find the last line that starts at or before our byte offset
    match line_index.binary_search(&byte_offset) {
        Ok(i) => i + 1,      // Exact match - byte is at line start
        Err(i) => i,         // byte is in line i (i lines start before it)
    }
}
```

Key implementation notes:
- line_starts[0] = 0 (first line starts at byte 0)
- Each newline adds the next line's start position
- binary_search provides O(log n) lookup
- Line numbers are 1-indexed for human readability (line 1, not line 0)
- char_indices() handles UTF-8 correctly (iterates by byte offset, not char index)
</action>
  <verify>`cargo build` succeeds</verify>
  <done>Line index function compiles and will be used in 04-02</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds with no errors
- [ ] build_line_index function correctly tracks newline positions
- [ ] byte_to_line function uses binary_search for efficient lookup
- [ ] Functions handle empty content (single line at position 0)
</verification>

<success_criteria>

- Line index builder function created
- Byte-to-line lookup function with O(log n) complexity
- Proper handling of file with no trailing newline
- Foundation ready for column calculation in 04-02
  </success_criteria>

<output>
After completion, create `.planning/phases/04-line-column-calc/04-01-SUMMARY.md`
</output>
