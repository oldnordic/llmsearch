---
phase: 05-context-extraction
plan: 03
type: execute
depends_on: ["05-02"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Handle edge cases for context extraction and update debug output.

Purpose: Ensure context extraction handles all edge cases (matches at file boundaries, empty files, matches on first/last line). Update debug output to show context.
Output: Robust context extraction with comprehensive edge case handling
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 5-02 provides context_after:
@.planning/phases/05-context-extraction/05-02-SUMMARY.md

# Current state:
@src/main.rs - Match struct has both context_before and context_after
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update debug output and verify edge cases</name>
  <files>src/main.rs</files>
  <action>Update debug output to show context extraction:

1. Update the debug loop to show context:
```rust
    // Debug: print first few matches with context
    for (i, m) in matches.iter().take(3).enumerate() {
        eprintln!("  Match {}: {}:{}:{}",
            i + 1, m.file, m.line_number, m.column_number);
        eprintln!("    Before: \"{}\"", m.context_before);
        eprintln!("    Match:  \"{}\"", m.matched_text.chars().take(30).collect::<String>());
        eprintln!("    After:  \"{}\"", m.context_after);
    }
```

2. Add edge case test (optional, for verification):
```rust
#[test]
fn test_context_extraction_edge_cases() {
    let content = "fn main() {\n    println!(\"Hello\");\n}";

    // Match at start of file
    let re = Regex::new(r"fn main").unwrap();
    let mat = re.find(content).unwrap();

    let context_start = 0.max(mat.start().saturating_sub(100));
    let context_before = content[context_start..mat.start()].to_string();
    assert_eq!(context_before, "");  // Nothing before match at start

    let remaining = &content[mat.end()..];
    let line_end = remaining.find('\n').unwrap_or(remaining.len());
    let context_end = mat.end() + line_end.min(100);
    let context_after = content[mat.end()..context_end.min(content.len())].to_string();
    assert!(context_after.contains("()"));  // Should have "()" after
}
```

3. Run tests to verify:
```bash
cargo test context
cargo test
```

Key implementation notes:
- Empty context_before for matches at start of file
- Empty context_after for matches at end of file/line
- saturating_sub() and min() prevent underflow/overflow
- Debug output shows full context preview (before, match, after)
</action>
  <verify>`cargo test` passes all context tests</verify>
  <done>Edge cases handled and debug output shows context</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] `cargo test` passes context extraction test
- [ ] Matches at start of file have empty context_before
- [ ] Matches at end of line have appropriate context_after
- [ ] Debug output shows before/match/after for verification
- [ ] No panics on empty files or boundary conditions
</verification>

<success_criteria>

- Context extraction handles all edge cases
- Matches at file boundaries produce appropriate (possibly empty) context
- Debug output clearly shows context extraction working
- Phase 5 complete: before/after context extraction fully implemented
  </success_criteria>

<output>
After completion, create `.planning/phases/05-context-extraction/05-03-SUMMARY.md`
</output>
