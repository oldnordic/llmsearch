---
phase: 05-context-extraction
plan: 01
type: execute
depends_on: []
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Extract context before each match.

Purpose: Add a `context_before` field to Match containing the text immediately before the match. This helps LLMs understand the surrounding code context.
Output: Match struct with context_before field populated
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 4 provides line/col positions:
@.planning/phases/04-line-column-calc/04-03-SUMMARY.md

# Current state:
@src/main.rs - Match struct has byte_start, byte_end, line_number, column_number
@Cargo.toml - All dependencies present
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add context_before field and extraction</name>
  <files>src/main.rs</files>
  <action>Add context_before extraction to Match struct and search_files:

1. Update Match struct:
```rust
struct Match {
    file: String,
    byte_start: usize,
    byte_end: usize,
    matched_text: String,
    line_number: usize,
    column_number: usize,
    context_before: String,  // NEW
}
```

2. Update search_files to extract context before match:
```rust
fn search_files(files: &[String], regex: &Regex) -> Vec<Match> {
    let mut matches = Vec::new();

    for file_path in files {
        match std::fs::read_to_string(file_path) {
            Ok(content) => {
                let line_index = build_line_index(&content);

                for mat in regex.find_iter(&content) {
                    let byte_start = mat.start();
                    let byte_end = mat.end();
                    let line_num = byte_to_line(byte_start, &line_index);
                    let line_start_byte = line_index[line_num - 1];
                    let col_num = byte_to_column(byte_start, line_start_byte, &content);

                    // Extract context before match (up to 100 chars or line start)
                    let context_start = line_start_byte.max(byte_start.saturating_sub(100));
                    let context_before = content[context_start..byte_start].to_string();

                    matches.push(Match {
                        file: file_path.clone(),
                        byte_start,
                        byte_end,
                        matched_text: mat.as_str().to_string(),
                        line_number: line_num,
                        column_number: col_num,
                        context_before,
                    });
                }
            }
            Err(e) => {
                eprintln!("Warning: Could not read {}: {}", file_path, e);
            }
        }
    }

    matches
}
```

Key implementation notes:
- Context limited to 100 characters before match OR line start (whichever is closer)
- Uses saturating_sub() to handle underflow at start of file/line
- Keeps context on single line (doesn't cross line boundaries)
- UTF-8 safe because we slice at byte boundaries we know are valid
</action>
  <verify>`cargo build` succeeds</verify>
  <done>context_before field populated with text before match</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] context_before field added to Match struct
- [ ] Context extracted up to 100 chars before match
- [ ] Context stops at line start (doesn't include previous line)
- [ ] No underflow at beginning of file
</verification>

<success_criteria>

- context_before field captures text immediately before match
- Limited to 100 characters or line boundary
- Safe handling of matches at start of file/line
- Foundation ready for context_after in 05-02
  </success_criteria>

<output>
After completion, create `.planning/phases/05-context-extraction/05-01-SUMMARY.md`
</output>
