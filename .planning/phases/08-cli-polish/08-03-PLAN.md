---
phase: 08-cli-polish
plan: 03
type: execute
depends_on: []
files_modified: [src/cli.rs, src/main.rs]
autonomous: true
---

<objective>
Add comprehensive error handling for invalid inputs and edge cases.

Purpose: Provide clear, actionable error messages for common user mistakes.
Output: Graceful error handling with helpful messages
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/cli.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Validate root directory exists</name>
  <files>src/main.rs</files>
  <action>Add validation for root directory early in main().

After parsing args (around line 208), add directory validation:

```rust
fn main() {
    let args = cli::Cli::parse();

    // Validate root directory exists
    let root_path = Path::new(&args.root);
    if !root_path.exists() {
        eprintln!(\"Error: Root directory does not exist: {}\", args.root);
        std::process::exit(1);
    }
    if !root_path.is_dir() {
        eprintln!(\"Error: Root path is not a directory: {}\", args.root);
        std::process::exit(1);
    }

    // Continue with rest of main()...
    let execution_id = Uuid::new_v4().to_string();
    // ...
}
```

This catches:
- Non-existent paths (typos, wrong directory)
- Files passed instead of directories
- Permission issues (exists() returns false if unreadable)

Error messages:
- Clear indication of what went wrong
- Shows the invalid path back to user
- Exit code 1 for scripting integration
</action>
  <verify>`cargo build` succeeds and `llmsearch -r /nonexistent -p test` exits with error</verify>
  <done>Invalid root directories produce helpful error messages and exit(1)</done>
</task>

<task type="auto">
  <name>Task 2: Validate pattern is non-empty</name>
  <files>src/main.rs</files>
  <action>Add validation for empty pattern after regex compilation check.

The current regex check handles invalid patterns, but empty patterns slip through.
Add explicit check:

```rust
// Validate pattern is non-empty
if args.pattern.is_empty() {
    eprintln!(\"Error: Pattern cannot be empty\");
    eprintln!(\"Usage: llmsearch -p '<pattern>'\");
    eprintln!(\"Provide a regex pattern to search for\");
    std::process::exit(1);
}

// Phase 3: Pattern matching
// Compile the regex pattern
let regex = match Regex::new(&args.pattern) {
    Ok(re) => re,
    Err(e) => {
        eprintln!(\"Error: Invalid regex pattern: {}\", e);
        eprintln!(\"Pattern: '{}'\", args.pattern);
        eprintln!(\"See: https://docs.rs/regex/latest/regex/#syntax\");
        std::process::exit(1);
    }
};
```

Improvements:
- Catches empty string before regex compilation
- Shows usage hint
- Existing regex error enhanced with pattern display and docs link
</action>
  <verify>`cargo build` succeeds and `llmsearch -p ''` exits with error about empty pattern</verify>
  <done>Empty patterns caught with helpful error message and usage hint</done>
</task>

<task type="auto">
  <name>Task 3: Validate limit is reasonable</name>
  <files>src/main.rs</files>
  <action>Add validation for limit argument to prevent unreasonable values.

After args parsing, add limit validation:

```rust
// Validate limit is reasonable
if args.limit == 0 {
    eprintln!(\"Error: Limit must be at least 1 (got: 0)\");
    std::process::exit(1);
}
if args.limit > 100_000 {
    eprintln!(\"Warning: Limit is very large ({}), may cause memory issues\", args.limit);
    eprintln!(\"Consider using a smaller limit or filtering with --glob\");
    // Continue execution - just a warning
}
```

Key behavior:
- Reject limit of 0 (no results would be meaningless)
- Warn on very large limits (>100k) but continue
- Warning helps users understand they may have requested too much

Alternative: Use clap's value_parser for range validation:
```rust
#[arg(short, long, default_value = \"100\", value_parser = clap::value_parser!(usize).range(1..))]
pub limit: usize,
```

This rejects 0 at parse time. Choose the approach that better fits the design.
</action>
  <verify>`cargo build` succeeds and `llmsearch -p test -l 0` exits with error</verify>
  <done>Limit of 0 rejected, very large limits produce warning</done>
</task>

<task type="auto">
  <name>Task 4: Report "no matches" gracefully</name>
  <files>src/main.rs</files>
  <action>Add user-friendly message when no matches are found.

After searching (around line 231), add check for empty results:

```rust
// Search files for pattern matches
let mut matches = search_files(&files, &regex);

if matches.is_empty() {
    if args.json {
        // Still output valid JSON with empty matches array
        let output = SearchOutput {
            execution_id,
            pattern: args.pattern.clone(),
            matches: vec![],
            match_count: 0,
        };
        match serde_json::to_string(&output) {
            Ok(json) => println!(\"{}\", json),
            Err(e) => {
                eprintln!(\"Error serializing to JSON: {}\", e);
                std::process::exit(1);
            }
        }
    } else {
        eprintln!(\"No matches found for pattern '{}'\", args.pattern);
        eprintln!(\"Searched {} file(s)\", files.len());
        if !args.glob.is_empty() {
            eprintln!(\"Filtered by glob(s): {:?}\", args.glob);
        }
    }
    std::process::exit(0);
}

// Continue with sorting, limiting, etc...
```

Behavior:
- JSON mode: Always outputs valid JSON (empty array is valid)
- Debug mode: Helpful message with search context
- Exit code 0 (not an error, just no results)
- Shows glob filters if used (helps debugging why no matches)
</action>
  <verify>`cargo build` succeeds and searching with no matches produces friendly message</verify>
  <done>"No matches" state handled gracefully in both JSON and debug modes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] `llmsearch -r /nonexistent -p test` exits with helpful error
- [ ] `llmsearch -p ''` exits with empty pattern error
- [ ] `llmsearch -p test -l 0` exits with limit error
- [ ] `llmsearch -p 'unlikelypatternxyz123'` shows "no matches" message
- [ ] `llmsearch -p 'unlikelypatternxyz123' --json` outputs valid JSON with empty array
</verification>

<success_criteria>

- Root directory validation with clear errors
- Pattern validation (non-empty, regex syntax help)
- Limit validation (0 rejected, large values warned)
- Graceful "no matches" handling in both modes
- Phase 8 complete: CLI fully polished and production-ready
  </success_criteria>

<output>
After completion, create `.planning/phases/08-cli-polish/08-03-SUMMARY.md`
</output>
