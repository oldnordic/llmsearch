---
phase: 07-deterministic-ordering
plan: 01
type: execute
depends_on: []
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Implement deterministic sorting by file path then byte offset.

Purpose: Ensure matches are returned in a consistent, repeatable order regardless of filesystem traversal order.
Output: Sorted match results (file path ascending, then byte_start ascending)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6 provides JSON output schema:
@.planning/phases/06-json-output/06-03-SUMMARY.md

# Current state:
@src/main.rs - Match struct has file and byte_start fields
@Cargo.toml - All dependencies present
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Ord derive to Match struct for sorting</name>
  <files>src/main.rs</files>
  <action>Add PartialOrd and Eq derives to Match struct for sorting:
```rust
#[derive(Serialize, Clone, PartialOrd, Eq)]
struct Match {
    match_id: String,
    file: String,
    byte_start: usize,
    byte_end: usize,
    matched_text: String,
    line_number: usize,
    column_number: usize,
    context_before: String,
    context_after: String,
}
```

Then implement manual Ord to sort by file then byte_start:
```rust
impl Ord for Match {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match self.file.cmp(&other.file) {
            std::cmp::Ordering::Equal => self.byte_start.cmp(&other.byte_start),
            other => other,
        }
    }
}
```

Key notes:
- PartialOrd and Eq required for Ord derive
- Manual Ord implementation ensures sorting by file path first, then byte position
- String comparison gives lexicographic path ordering (deterministic)
- usize comparison gives byte offset ordering (deterministic within same file)
</action>
  <verify>`cargo build` succeeds</verify>
  <done>Match struct sortable with deterministic ordering</done>
</task>

<task type="auto">
  <name>Task 2: Sort matches in main before creating output</name>
  <files>src/main.rs</files>
  <action>In main function, after collecting matches, sort them:
```rust
    // Search files for pattern matches
    let mut matches = search_files(&files, &regex);
    eprintln!("Found {} matches", matches.len());

    // Phase 7: Deterministic ordering
    // Sort by file path, then byte_start for consistent output
    matches.sort();
    eprintln!("Matches sorted deterministically");
```

Changes:
- Change `let matches` to `let mut matches` (needs mutability for sort)
- Call `matches.sort()` after search_files
- Uses the Ord implementation from Task 1
- Sort is stable and deterministic across runs
</action>
  <verify>`cargo build` succeeds and running llmsearch shows sorted output</verify>
  <done>Matches sorted before JSON output</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] Match struct has PartialOrd, Eq, Ord implemented
- [ ] Ord sorts by file path then byte_start
- [ ] matches.sort() called in main before output
- [ ] Multiple runs return matches in same order
</verification>

<success_criteria>

- Matches sorted by file path (lexicographic)
- Within same file, sorted by byte_start (ascending)
- Order is deterministic across multiple runs
- Ready for limit functionality in 07-02
  </success_criteria>

<output>
After completion, create `.planning/phases/07-deterministic-ordering/07-01-SUMMARY.md`
</output>
