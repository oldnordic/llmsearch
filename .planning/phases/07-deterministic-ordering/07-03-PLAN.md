---
phase: 07-deterministic-ordering
plan: 03
type: execute
depends_on: ["07-02"]
files_modified: [src/main.rs]
autonomous: true
---

<objective>
Verify deterministic ordering with tests.

Purpose: Ensure sorting and limiting produce consistent, repeatable results across multiple runs.
Output: Tests confirming deterministic behavior
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 7-01 provides sorting:
@.planning/phases/07-deterministic-ordering/07-01-SUMMARY.md

# Phase 7-02 provides limit:
@.planning/phases/07-deterministic-ordering/07-02-SUMMARY.md

# Current state:
@src/main.rs - Match has Ord implementation, matches sorted and limited
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add test for deterministic Match ordering</name>
  <files>src/main.rs</files>
  <action>Add unit test in tests module to verify Match ordering:
```rust
#[test]
fn test_match_ordering() {
    let match_a = Match {
        match_id: "id-a".to_string(),
        file: "src/b.rs".to_string(),
        byte_start: 100,
        byte_end: 110,
        matched_text: "foo".to_string(),
        line_number: 5,
        column_number: 1,
        context_before: String::new(),
        context_after: String::new(),
    };

    let match_b = Match {
        match_id: "id-b".to_string(),
        file: "src/a.rs".to_string(),  // Earlier path alphabetically
        byte_start: 200,
        byte_end: 210,
        matched_text: "bar".to_string(),
        line_number: 10,
        column_number: 1,
        context_before: String::new(),
        context_after: String::new(),
    };

    let match_c = Match {
        match_id: "id-c".to_string(),
        file: "src/a.rs".to_string(),  // Same file as match_b
        byte_start: 50,   // Earlier byte position
        byte_end: 60,
        matched_text: "baz".to_string(),
        line_number: 2,
        column_number: 1,
        context_before: String::new(),
        context_after: String::new(),
    };

    let mut matches = vec![match_a.clone(), match_b.clone(), match_c.clone()];
    matches.sort();

    // Should order: src/a.rs:50 (c), src/a.rs:200 (b), src/b.rs:100 (a)
    assert_eq!(matches[0].file, "src/a.rs");
    assert_eq!(matches[0].byte_start, 50);
    assert_eq!(matches[1].file, "src/a.rs");
    assert_eq!(matches[1].byte_start, 200);
    assert_eq!(matches[2].file, "src/b.rs");
    assert_eq!(matches[2].byte_start, 100);
}
```

Test verifies:
- Matches sorted by file path first (src/a.rs before src/b.rs)
- Within same file, sorted by byte_start (50 before 200)
- Ordering is deterministic and consistent
</action>
  <verify>`cargo test test_match_ordering` passes</verify>
  <done>Test confirms deterministic ordering by file then byte_start</done>
</task>

<task type="auto">
  <name>Task 2: Add test for limit functionality</name>
  <files>src/main.rs</files>
  <action>Add unit test for limit behavior:
```rust
#[test]
fn test_limit_functionality() {
    let matches: Vec<Match> = (0..10).map(|i| Match {
        match_id: format!("id-{}", i),
        file: format!("file{}.rs", i / 3),
        byte_start: i * 10,
        byte_end: i * 10 + 3,
        matched_text: "test".to_string(),
        line_number: i,
        column_number: 1,
        context_before: String::new(),
        context_after: String::new(),
    }).collect();

    // Apply limit of 5
    let limit = 5;
    let limited: Vec<Match> = matches.into_iter().take(limit).collect();

    assert_eq!(limited.len(), 5);
    assert_eq!(limited[0].byte_start, 0);   // First match
    assert_eq!(limited[4].byte_start, 40);  // Fifth match
}
```

Test verifies:
- take(limit) correctly truncates results
- Limit doesn't panic when smaller than collection
- First N items are returned after sorting
</action>
  <verify>`cargo test test_limit_functionality` passes</verify>
  <done>Test confirms limit works correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds
- [ ] `cargo test` passes all ordering tests
- [ ] test_match_ordering confirms file then byte_start ordering
- [ ] test_limit_functionality confirms truncate behavior
- [ ] No regression in existing tests
</verification>

<success_criteria>

- Ordering tests pass consistently
- File path ordering verified
- Byte offset ordering within files verified
- Limit behavior tested
- Phase 7 complete: deterministic ordering fully implemented and tested
  </success_criteria>

<output>
After completion, create `.planning/phases/07-deterministic-ordering/07-03-SUMMARY.md`
</output>
